--=======================================================================================
-- Generated by TypescriptToLua transpiler https://github.com/Perryvw/TypescriptToLua 
-- Date: Sun May 13 2018
--=======================================================================================
require("typescript_lualib")
--LinkLuaModifier("modifier_random_spell_mutator","",LUA_MODIFIER_MOTION_NONE)
modifier_random_spell_mutator = {}
modifier_random_spell_mutator.__index = modifier_random_spell_mutator
function modifier_random_spell_mutator.new(construct, ...)
    local instance = setmetatable({}, modifier_random_spell_mutator)
    if construct and modifier_random_spell_mutator.constructor then modifier_random_spell_mutator.constructor(instance, ...) end
    return instance
end
function modifier_random_spell_mutator.IsPermanent(self)
    return true
end
function modifier_random_spell_mutator.IsPurgable(self)
    return false
end
function modifier_random_spell_mutator.IsHidden(self)
    return true
end
function modifier_random_spell_mutator.CheckState(self)
    return {[MODIFIER_STATE_INVISIBLE]=true,[MODIFIER_STATE_INVULNERABLE]=true,[MODIFIER_STATE_TRUESIGHT_IMMUNE]=true,[MODIFIER_STATE_NO_UNIT_COLLISION]=true}
end
function modifier_random_spell_mutator.OnCreated(self)
    if IsClient() then
        return
    end
    self.level_up_duration=5
    self.cast_interval=60
    self.warning_time=(self.cast_interval-5)
    self.random_spells={"invoker_retro_disarm", "dark_seer_surge", "dark_seer_ion_shell","lion_voodoo", "oracle_false_promise", "tusk_walrus_kick", "light_blade","lich_chain_frost", "furion_sprout", "gyrocopter_homing_missile", "keeper_of_the_light_mana_leak","bloodseeker_rupture","zuus_lightning_bolt","invoker_sun_strike","kunkka_torrent","ancient_apparition_cold_feet","disruptor_glimpse","rubick_telekinesis"}
    local unit = self:GetParent()
    TS_forEach(self.random_spells, function(spell)
        local ability = unit:AddAbility(spell)
        PrecacheItemByNameAsync(spell, function() end)
        ability:SetLevel(1)
    end
)
    self:StartIntervalThink(FrameTime())
end
function modifier_random_spell_mutator.OnIntervalThink(self)
    -- Make sure the think interval is near whole numbers
    if not self.whole and  GameRules:GetDOTATime(false,false)  < 1-FrameTime()  then
        return
    end
    if not self.whole and GameRules:GetDOTATime(false,false) >= 1-FrameTime() then
        self.whole = true
        self:StartIntervalThink(1)
    end

    if math.floor(GameRules:GetDOTATime(false,false)%60)==self.warning_time then
        local unit = self:GetParent()
        local rnd = RandomInt(0,#self.random_spells-1)
        self.abilityName = self.random_spells[rnd+1]
        Notifications:TopToAll({ability=self.abilityName, duration=5.0})

        PrecacheItemByNameAsync(self.abilityName, function() print(self.abilityName.."precached") end)

        local sounds = {
            "ui_find_match_cancel",
            "ui_find_match_change_options", 
            "ui_custom_lobby_drawer_slide_in",
            "ui_custom_lobby_drawer_slide_out",
        }
        EmitGlobalSound(sounds[RandomInt(1,#sounds)])   
        TS_forEach(self.random_spells, function(spell)
            local ability = unit:FindAbilityByName(spell)

            ability:SetLevel(math.min(math.floor(GameRules:GetGameTime()/5),ability:GetMaxLevel()))
        end)
    end
    if GameRules:GetDOTATime(false,false) > 0 and math.floor(GameRules:GetDOTATime(false,false)%60)==0 then
        local unit = self:GetParent()

        local rnd = RandomInt(0,#self.random_spells-1)
        --self.abilityName = self.abilityName or self.random_spells[rnd+1]
        if not self.abilityName then return end
        local ability = unit:FindAbilityByName(self.abilityName)

        local targets = FindUnitsInRadius(DOTA_TEAM_NEUTRALS,Vector(0,0,0),nil,100000,DOTA_UNIT_TARGET_TEAM_BOTH,DOTA_UNIT_TARGET_HERO,DOTA_UNIT_TARGET_FLAG_NONE,FIND_ANY_ORDER,false)



        TS_forEach(targets, function(hero)
            if ability:GetAbilityTargetTeam() == DOTA_UNIT_TARGET_TEAM_FRIENDLY then
                unit:SetTeam(hero:GetTeam())
            else
                unit:SetTeam(DOTA_TEAM_NEUTRALS )
            end

            if (bit.band(ability:GetBehavior(),DOTA_ABILITY_BEHAVIOR_UNIT_TARGET))==DOTA_ABILITY_BEHAVIOR_UNIT_TARGET then
                unit:SetCursorCastTarget(hero)
                ability:OnSpellStart()
                --unit:CastAbilityOnTarget( hero, ability, -1 )
            elseif (bit.band(ability:GetBehavior(),DOTA_ABILITY_BEHAVIOR_POINT))==DOTA_ABILITY_BEHAVIOR_POINT then
                unit:SetCursorCastTarget(hero)
                unit:SetCursorPosition(hero:GetAbsOrigin())
                ability:OnSpellStart()
                --unit:CastAbilityOnPosition( hero:GetAbsOrigin(), ability, -1 )
            elseif (bit.band(ability:GetBehavior(),DOTA_ABILITY_BEHAVIOR_NO_TARGET))==DOTA_ABILITY_BEHAVIOR_NO_TARGET then
                ability:OnSpellStart()
                --unit:CastAbilityNoTarget(ability,-1)
            end
        end)
    end
end
